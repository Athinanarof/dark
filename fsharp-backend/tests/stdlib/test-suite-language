5 + 3 = 8 // int_add_works
String.join_v0 (List.foreach_v0 (String.toList_v1 "some string") (\var -> String.toUppercase_v0 (String.fromChar_v1 var))) "" = "SOME STRING" // lambda_with_foreach
match 5\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "int"s
match 5.6\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "float"s
match false\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "bool"s
match "myStr"\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "string"s
match "otherStr"\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "otherStrvar"s
match null\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "null"s
match Ok "x"\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "ok: x"s
match Nothing\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "constructor nothing"s
match "not matched: "\n  5 -> "int"\n  5.6 -> "float"\n  false -> "bool"\n  "myStr" -> "string"\n  null -> "null"\n  blank -> "blank"\n  Ok x -> ++_v0 "ok: " x\n  Nothing -> "constructor nothing"\n  name -> ++_v0 name "var"\n = "not matched: var"s
[5]\n|>List.head_v1\n|>+ 3\n|>\x -> if (x + 4) > 1\n        then\n          x\n        else\n          (1 + x)\n = 8 // pipe works
Nothing = Nothing // Handling nothing in code works
(List.head_v1 []) == Nothing = true // Handling nothing in code works
[5;6;List.head_v0 blank] = [ \n  5, 6\n] // Incompletes propagate correctly
[5;6;blank] = [ \n  5, 6\n] // Incompletes propagate correctly
{\n  i = blank\n  m = 5\n  j = List.head_v0 blank\n  n = 6\n} = { \n  n: 6,\n  m: 5\n} // Incompletes propagate correctly
5\n|>blank\n|>+ 3\n = 8 // Incompletes propagate correctly
5\n|>+ blank\n|>+ 3\n = 8 // Incompletes propagate correctly
5\n|>+ blank\n = 5 // Incompletes propagate correctly
Error (List.last_v1 []) = ErrorRail: Nothing // Errorrail simple
Dict.get_v1 {} "i" = Nothing // Errorrail simple
[5]\n|>List.head_v1\n|>+ 3\n|>\x -> if (x + 4) > 1\n        then\n          x\n        else\n          (1 + x)\n = 8 // Errorrail simple
[]\n|>List.head_v1\n|>+ 3\n|>\x -> if (x + 4) > 1\n        then\n          x\n        else\n          (1 + x)\n = ErrorRail: Nothing // Errorrail simple
myGoodFn_v0 = "str" // Type checkingfor return types
myAnyFn_v0 = 5 // Type checkingfor return types
List.push_v0 [1;2;3;4] (List.head_v1 []) = ErrorRail: Nothing // Error rail is propagated by functions
List.filter_v1 [1;2;3;4] (\x -> List.head_v1 []) = ErrorRail: Nothing // Error rail is propagated by functions
List.map_v0 [1;2;3;4] (\x -> List.head_v1 []) = ErrorRail: Nothing // Error rail is propagated by functions
List.fold_v0 [1;2;3;4] 1 (\x, y -> List.head_v1 []) = ErrorRail: Nothing // Error rail is propagated by functions
Error (List.last_v1 []) = ErrorRail: Nothing // DError propagation
let x = 5\nlet y = \c -> x + c\nlet x = 6\n[1;2;3;4]\n|>List.map_v0 y\n = [ \n  6, 7, 8, 9\n] // lambda scopes correctly
match 6\n  5 -> "fail"\n  6 -> "pass"\n  var -> "fail"\n = "pass"
match "x"\n  "y" -> "fail"\n  "x" -> "pass"\n  var -> "fail"\n = "pass"
match true\n  false -> "fail"\n  true -> "pass"\n  var -> "fail"\n = "pass"
match 2.0\n  1.0 -> "fail"\n  2.0 -> "pass"\n  var -> "fail"\n = "pass"
match null\n  null -> "pass"\n  var -> "fail"\n = "pass"
match 2.0\n  blank -> "fail"\n  2.0 -> "pass"\n  var -> "fail"\n = "pass"
let x = 5\nlet x = 6\nx = 6 // shadowing all the way down
let x = 35\nmatch 6\n  x -> x\n = 6 // shadowing all the way down
let x = 35\nmatch Ok 6\n  Ok x -> x\n = 6 // shadowing all the way down
let x = 35\nList.map_v0 [1;2;3;4] (\x -> +_v0 x 2) = [ \n  3, 4, 5, 6\n] // shadowing all the way down
let x = 35\nmatch Ok 6\n  Ok x -> List.map_v0 [1;2;3;4] (\x -> +_v0 x 2)\n = [ \n  3, 4, 5, 6\n] // shadowing all the way down
List.map_v0 [1;2;3;4] (\x -> let x = 35\n                              match Ok 6\n                                Ok x -> +_v0 x 2\n                       ) = [ \n  8, 8, 8, 8\n] // shadowing all the way down
List.map_v0 [1;2;3;4] (\x -> match Ok 6\n                                Ok x -> let x = 9\n                                        +_v0 x 2\n                       ) = [ \n  11, 11, 11, 11\n] // shadowing all the way down
